diff --git a/build/Controls.js b/build/Controls.js
index 55a635c0425dce02e53253a783fee556fb650d96..413cbf631e95da3e4dcdaa7beac42571ebdb0c09 100644
--- a/build/Controls.js
+++ b/build/Controls.js
@@ -1 +1,284 @@
-function _extends(){return _extends=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends.apply(this,arguments)}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}import React from"react";import PropTypes from"prop-types";import{StyleSheet,Text,View}from"react-native";import{nodeType}from"./nodeType";import{renderNode}from"./renderNode";import{Badge}from"./Badge";import{Button}from"./Button";import colors from"./colors";const cellPositions=["top-left","top","top-right","left","center","right","bottom-left","bottom","bottom-right"];export default class DefaultControls extends React.Component{constructor(a){super(a),_defineProperty(this,"dotsPos",(()=>this._getPos(this.props.dotsPos,"bottom","right"))()),_defineProperty(this,"prevPos",(()=>this._getPos(this.props.prevPos,"bottom-left","top-right"))()),_defineProperty(this,"nextPos",(()=>this._getPos(this.props.nextPos,"bottom-right"))()),this._renderRow=this._renderRow.bind(this),this._renderCell=this._renderCell.bind(this),this._renderDot=this._renderDot.bind(this),this._renderButton=this._renderButton.bind(this)}_getPos(a,b,c){return!1===a?null:a?a:c&&this.props.vertical?c:b}_renderDot({isActive:a,onPress:b}){const{dotProps:d={},dotActiveStyle:c}=this.props,{containerStyle:e,badgeStyle:f,...g}=d;return/*#__PURE__*/React.createElement(Badge,_extends({theme:{colors},containerStyle:StyleSheet.flatten([styles.dotsItemContainer,e]),badgeStyle:StyleSheet.flatten([styles.dotsItem({colors},a),f,a&&c]),onPress:b},g))}_renderDots(){const{vertical:a,count:b,activeIndex:c,dotsTouchable:d,dotsWrapperStyle:e,DotComponent:g=this._renderDot,goTo:f}=this.props;return/*#__PURE__*/React.createElement(View,{style:StyleSheet.flatten([styles.dotsWrapper(a),e])},Array.from({length:b},(a,b)=>b).map(a=>/*#__PURE__*/React.createElement(g,{key:a,index:a,activeIndex:c,isActive:c===a,onPress:d?()=>f(a):void 0})))}_renderButton({type:a,title:b,titleStyle:c,onPress:d,...e}){return/*#__PURE__*/React.createElement(Button,_extends({theme:{colors},type:"clear",onPress:d,title:b,titleStyle:StyleSheet.flatten([styles.buttonTitleStyle({colors},a),c])},e))}_renderPrev(){const{goToPrev:a,isFirst:b,prevTitle:c,firstPrevElement:d,prevTitleStyle:e,PrevComponent:f=this._renderButton}=this.props;return b?renderNode(Text,d):/*#__PURE__*/React.createElement(f,{type:"prev",title:c,titleStyle:e,onPress:a})}_renderNext(){const{goToNext:a,isLast:b,nextTitle:c,lastNextElement:d,nextTitleStyle:e,NextComponent:f=this._renderButton}=this.props;return b?renderNode(Text,d):/*#__PURE__*/React.createElement(f,{type:"next",title:c,titleStyle:e,onPress:a})}_renderCell({name:a}){const{cellsStyle:b={},cellsContent:c={}}=this.props;return/*#__PURE__*/React.createElement(View,{style:StyleSheet.flatten([styles.cell,b[a]])},this.dotsPos===a&&this._renderDots(),this.prevPos===a&&this._renderPrev(),this.nextPos===a&&this._renderNext(),c[a]&&renderNode(Text,c[a]))}_renderRow({rowAlign:a}){const b=this._renderCell,c=[`${a?a+"-":""}left`,a||"center",`${a?a+"-":""}right`],d=["flex-start","center","flex-end"];return/*#__PURE__*/React.createElement(View,{style:styles.row},c.map((a,c)=>/*#__PURE__*/React.createElement(View,{key:a,style:styles.spaceHolder(d[c])},/*#__PURE__*/React.createElement(b,{name:a}))))}render(){const a=this._renderRow;return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(a,{rowAlign:"top",contentAlign:"flex-start"}),/*#__PURE__*/React.createElement(a,{contentAlign:"center"}),/*#__PURE__*/React.createElement(a,{rowAlign:"bottom",contentAlign:"flex-end"}))}}DefaultControls.propTypes={cellsStyle:PropTypes.shape(cellPositions.reduce((a,b)=>({...a,[b]:PropTypes.style}),{})),cellsContent:PropTypes.shape(cellPositions.reduce((a,b)=>({...a,[b]:nodeType}),{})),dotsPos:PropTypes.oneOf([...cellPositions,!0,!1]),prevPos:PropTypes.oneOf([...cellPositions,!0,!1]),nextPos:PropTypes.oneOf([...cellPositions,!0,!1]),prevTitle:PropTypes.string,nextTitle:PropTypes.string,dotsTouchable:PropTypes.bool,dotsWrapperStyle:PropTypes.shape({style:PropTypes.any}),dotProps:PropTypes.shape(Badge.propTypes),dotActiveStyle:PropTypes.shape({style:PropTypes.any}),DotComponent:PropTypes.func,prevTitleStyle:PropTypes.shape({style:PropTypes.any}),nextTitleStyle:PropTypes.shape({style:PropTypes.any}),PrevComponent:PropTypes.func,NextComponent:PropTypes.func,firstPrevElement:nodeType,lastNextElement:nodeType,theme:PropTypes.object,vertical:PropTypes.bool,count:PropTypes.number,activeIndex:PropTypes.number,isFirst:PropTypes.bool,isLast:PropTypes.bool,goToPrev:PropTypes.func,goToNext:PropTypes.func,goTo:PropTypes.func},DefaultControls.defaultProps={prevTitle:"Prev",nextTitle:"Next"};const styles={row:{flexDirection:"row",height:0,alignItems:"center",margin:20},spaceHolder:a=>({height:0,flex:1,alignItems:a,justifyContent:"center"}),cell:{alignItems:"center",justifyContent:"center",position:"absolute"},dotsWrapper:a=>({flexDirection:a?"column":"row",alignItems:"center",justifyContent:"center",minWidth:1,minHeight:1}),dotsItemContainer:{margin:3},dotsItem:(a,b)=>({backgroundColor:b?a.colors.primary:a.colors.grey3,borderColor:"transparent"}),buttonTitleStyle:(a,b)=>({color:"prev"===b?a.colors.grey3:a.colors.primary}),hidden:{opacity:0}};
\ No newline at end of file
+function _extends() {
+  return (
+    (_extends =
+      Object.assign ||
+      function (a) {
+        for (var b, c = 1; c < arguments.length; c++)
+          for (var d in ((b = arguments[c]), b))
+            Object.prototype.hasOwnProperty.call(b, d) && (a[d] = b[d]);
+        return a;
+      }),
+    _extends.apply(this, arguments)
+  );
+}
+function _defineProperty(a, b, c) {
+  return (
+    b in a
+      ? Object.defineProperty(a, b, {
+          value: c,
+          enumerable: !0,
+          configurable: !0,
+          writable: !0,
+        })
+      : (a[b] = c),
+    a
+  );
+}
+import React from "react";
+import PropTypes from "prop-types";
+import { StyleSheet, Text, View } from "react-native";
+import { nodeType } from "./nodeType";
+import { renderNode } from "./renderNode";
+import { Badge } from "./Badge";
+import { Button } from "./Button";
+import colors from "./colors";
+const cellPositions = [
+  "top-left",
+  "top",
+  "top-right",
+  "left",
+  "center",
+  "right",
+  "bottom-left",
+  "bottom",
+  "bottom-right",
+];
+export default class DefaultControls extends React.Component {
+  constructor(a) {
+    super(a),
+      _defineProperty(
+        this,
+        "dotsPos",
+        (() => this._getPos(this.props.dotsPos, "bottom", "right"))()
+      ),
+      _defineProperty(
+        this,
+        "prevPos",
+        (() => this._getPos(this.props.prevPos, "bottom-left", "top-right"))()
+      ),
+      _defineProperty(
+        this,
+        "nextPos",
+        (() => this._getPos(this.props.nextPos, "bottom-right"))()
+      ),
+      (this._renderRow = this._renderRow.bind(this)),
+      (this._renderCell = this._renderCell.bind(this)),
+      (this._renderDot = this._renderDot.bind(this)),
+      (this._renderButton = this._renderButton.bind(this));
+  }
+  _getPos(a, b, c) {
+    return !1 === a ? null : a ? a : c && this.props.vertical ? c : b;
+  }
+  _renderDot({ isActive: a, onPress: b }) {
+    const { dotProps: d = {}, dotActiveStyle: c } = this.props,
+      { containerStyle: e, badgeStyle: f, ...g } = d;
+    return /*#__PURE__*/ React.createElement(
+      Badge,
+      _extends(
+        {
+          theme: { colors },
+          containerStyle: StyleSheet.flatten([styles.dotsItemContainer, e]),
+          badgeStyle: StyleSheet.flatten([
+            styles.dotsItem({ colors }, a),
+            f,
+            a && c,
+          ]),
+          onPress: b,
+        },
+        g
+      )
+    );
+  }
+  _renderDots() {
+    const {
+      vertical: a,
+      count: b,
+      activeIndex: c,
+      dotsTouchable: d,
+      dotsWrapperStyle: e,
+      DotComponent: g = this._renderDot,
+      goTo: f,
+      numberOfSteps: x,
+    } = this.props;
+    return /*#__PURE__*/ React.createElement(
+      View,
+      { style: StyleSheet.flatten([styles.dotsWrapper(a), e]) },
+      Array.from({ length: b }, (a, b) => b).map((a) =>
+        /*#__PURE__*/ React.createElement(g, {
+          key: a,
+          index: a,
+          activeIndex: c,
+          isActive: c === a,
+          onPress: d ? () => f(a) : void 0,
+          numberOfSteps: x,
+        })
+      )
+    );
+  }
+  _renderButton({ type: a, title: b, titleStyle: c, onPress: d, ...e }) {
+    return /*#__PURE__*/ React.createElement(
+      Button,
+      _extends(
+        {
+          theme: { colors },
+          type: "clear",
+          onPress: d,
+          title: b,
+          titleStyle: StyleSheet.flatten([
+            styles.buttonTitleStyle({ colors }, a),
+            c,
+          ]),
+        },
+        e
+      )
+    );
+  }
+  _renderPrev() {
+    const {
+      goToPrev: a,
+      isFirst: b,
+      prevTitle: c,
+      firstPrevElement: d,
+      prevTitleStyle: e,
+      PrevComponent: f = this._renderButton,
+    } = this.props;
+    return b
+      ? renderNode(Text, d)
+      : /*#__PURE__*/ React.createElement(f, {
+          type: "prev",
+          title: c,
+          titleStyle: e,
+          onPress: a,
+        });
+  }
+  _renderNext() {
+    const {
+      goToNext: a,
+      isLast: b,
+      nextTitle: c,
+      lastNextElement: d,
+      nextTitleStyle: e,
+      NextComponent: f = this._renderButton,
+    } = this.props;
+    return b
+      ? renderNode(Text, d)
+      : /*#__PURE__*/ React.createElement(f, {
+          type: "next",
+          title: c,
+          titleStyle: e,
+          onPress: a,
+        });
+  }
+  _renderCell({ name: a }) {
+    const { cellsStyle: b = {}, cellsContent: c = {} } = this.props;
+    return /*#__PURE__*/ React.createElement(
+      View,
+      { style: StyleSheet.flatten([styles.cell, b[a]]) },
+      this.dotsPos === a && this._renderDots(),
+      this.prevPos === a && this._renderPrev(),
+      this.nextPos === a && this._renderNext(),
+      c[a] && renderNode(Text, c[a])
+    );
+  }
+  _renderRow({ rowAlign: a }) {
+    const b = this._renderCell,
+      c = [
+        `${a ? a + "-" : ""}left`,
+        a || "center",
+        `${a ? a + "-" : ""}right`,
+      ],
+      d = ["flex-start", "center", "flex-end"];
+    return /*#__PURE__*/ React.createElement(
+      View,
+      { style: styles.row },
+      c.map((a, c) =>
+        /*#__PURE__*/ React.createElement(
+          View,
+          { key: a, style: styles.spaceHolder(d[c]) },
+          /*#__PURE__*/ React.createElement(b, { name: a })
+        )
+      )
+    );
+  }
+  render() {
+    const a = this._renderRow;
+    return /*#__PURE__*/ React.createElement(
+      React.Fragment,
+      null,
+      /*#__PURE__*/ React.createElement(a, {
+        rowAlign: "top",
+        contentAlign: "flex-start",
+      }),
+      /*#__PURE__*/ React.createElement(a, { contentAlign: "center" }),
+      /*#__PURE__*/ React.createElement(a, {
+        rowAlign: "bottom",
+        contentAlign: "flex-end",
+      })
+    );
+  }
+}
+(DefaultControls.propTypes = {
+  cellsStyle: PropTypes.shape(
+    cellPositions.reduce((a, b) => ({ ...a, [b]: PropTypes.style }), {})
+  ),
+  cellsContent: PropTypes.shape(
+    cellPositions.reduce((a, b) => ({ ...a, [b]: nodeType }), {})
+  ),
+  dotsPos: PropTypes.oneOf([...cellPositions, !0, !1]),
+  prevPos: PropTypes.oneOf([...cellPositions, !0, !1]),
+  nextPos: PropTypes.oneOf([...cellPositions, !0, !1]),
+  prevTitle: PropTypes.string,
+  nextTitle: PropTypes.string,
+  dotsTouchable: PropTypes.bool,
+  dotsWrapperStyle: PropTypes.shape({ style: PropTypes.any }),
+  dotProps: PropTypes.shape(Badge.propTypes),
+  dotActiveStyle: PropTypes.shape({ style: PropTypes.any }),
+  DotComponent: PropTypes.func,
+  prevTitleStyle: PropTypes.shape({ style: PropTypes.any }),
+  nextTitleStyle: PropTypes.shape({ style: PropTypes.any }),
+  PrevComponent: PropTypes.func,
+  NextComponent: PropTypes.func,
+  firstPrevElement: nodeType,
+  lastNextElement: nodeType,
+  theme: PropTypes.object,
+  vertical: PropTypes.bool,
+  count: PropTypes.number,
+  activeIndex: PropTypes.number,
+  isFirst: PropTypes.bool,
+  isLast: PropTypes.bool,
+  goToPrev: PropTypes.func,
+  goToNext: PropTypes.func,
+  goTo: PropTypes.func,
+  numberOfSteps: PropTypes.number,
+}),
+  (DefaultControls.defaultProps = { prevTitle: "Prev", nextTitle: "Next" });
+const styles = {
+  row: { flexDirection: "row", height: 0, alignItems: "center", margin: 20 },
+  spaceHolder: (a) => ({
+    height: 0,
+    flex: 1,
+    alignItems: a,
+    justifyContent: "center",
+  }),
+  cell: {
+    alignItems: "center",
+    justifyContent: "center",
+    position: "absolute",
+  },
+  dotsWrapper: (a) => ({
+    flexDirection: a ? "column" : "row",
+    alignItems: "center",
+    justifyContent: "center",
+    minWidth: 1,
+    minHeight: 1,
+  }),
+  dotsItemContainer: { margin: 3 },
+  dotsItem: (a, b) => ({
+    backgroundColor: b ? a.colors.primary : a.colors.grey3,
+    borderColor: "transparent",
+  }),
+  buttonTitleStyle: (a, b) => ({
+    color: "prev" === b ? a.colors.grey3 : a.colors.primary,
+  }),
+  hidden: { opacity: 0 },
+};
diff --git a/index.d.ts b/index.d.ts
index 0a80b15cfd702fdf79c1b0c3b783dbc06365107e..98fd98c715f5632172e3468503d81800db96e55f 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -1,9 +1,5 @@
-import * as React from 'react';
-import {
-    ViewStyle,
-    TextStyle,
-    StyleProp,
-} from 'react-native';
+import * as React from "react";
+import { ViewStyle, TextStyle, StyleProp } from "react-native";
 
 type Falsy = undefined | null | false;
 interface RecursiveArray<T> extends Array<T | RecursiveArray<T>> {}
@@ -11,363 +7,368 @@ interface RecursiveArray<T> extends Array<T | RecursiveArray<T>> {}
 type RegisteredStyle<T> = number & { __registeredStyleBrand: T };
 
 export type SwiperControlsCorners =
-    | 'top-left'
-    | 'top'
-    | 'top-right'
-    | 'left'
-    | 'center'
-    | 'right'
-    | 'bottom-left'
-    | 'bottom'
-    | 'bottom-right';
+  | "top-left"
+  | "top"
+  | "top-right"
+  | "left"
+  | "center"
+  | "right"
+  | "bottom-left"
+  | "bottom"
+  | "bottom-right";
 
 // TODO: optimize
 interface SwiperControlsCellsStyle {
-    'top-left'?: StyleProp<ViewStyle>;
-    top?: StyleProp<ViewStyle>;
-    'top-right'?: StyleProp<ViewStyle>;
-    left?: StyleProp<ViewStyle>;
-    center?: StyleProp<ViewStyle>;
-    right?: StyleProp<ViewStyle>;
-    'bottom-left'?: StyleProp<ViewStyle>;
-    bottom?: StyleProp<ViewStyle>;
-    'bottom-right'?: StyleProp<ViewStyle>;
+  "top-left"?: StyleProp<ViewStyle>;
+  top?: StyleProp<ViewStyle>;
+  "top-right"?: StyleProp<ViewStyle>;
+  left?: StyleProp<ViewStyle>;
+  center?: StyleProp<ViewStyle>;
+  right?: StyleProp<ViewStyle>;
+  "bottom-left"?: StyleProp<ViewStyle>;
+  bottom?: StyleProp<ViewStyle>;
+  "bottom-right"?: StyleProp<ViewStyle>;
 }
 interface SwiperControlsCellsContent {
-    'top-left'?: React.ReactElement<{}>;
-    top?: React.ReactElement<{}>;
-    'top-right'?: React.ReactElement<{}>;
-    left?: React.ReactElement<{}>;
-    center?: React.ReactElement<{}>;
-    right?: React.ReactElement<{}>;
-    'bottom-left'?: React.ReactElement<{}>;
-    bottom?: React.ReactElement<{}>;
-    'bottom-right'?: React.ReactElement<{}>;
+  "top-left"?: React.ReactElement<{}>;
+  top?: React.ReactElement<{}>;
+  "top-right"?: React.ReactElement<{}>;
+  left?: React.ReactElement<{}>;
+  center?: React.ReactElement<{}>;
+  right?: React.ReactElement<{}>;
+  "bottom-left"?: React.ReactElement<{}>;
+  bottom?: React.ReactElement<{}>;
+  "bottom-right"?: React.ReactElement<{}>;
 }
 
 export interface BadgeProps {
-    /**
-     * Text value to be displayed by badge
-     *
-     * @default null
-     */
-    value?: React.ReactNode;
-
-    /**
-     * Additional styling for badge (background) view component
-     */
-    badgeStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Style for the container
-     */
-    containerStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Style for the text in the badge
-     */
-    textStyle?: StyleProp<TextStyle>;
-
-    /**
-     * Custom component to replace the badge component
-     *
-     * @default View (if onPress then TouchableOpacity)
-     */
-    Component?: React.ComponentClass;
-
-    /**
-     * Determines color of the indicator
-     *
-     * @default primary
-     */
-    status?: 'primary' | 'success' | 'warning' | 'error';
-
-    /**
-     * Function called when pressed on the badge
-     */
-    onPress?(): void;
+  /**
+   * Text value to be displayed by badge
+   *
+   * @default null
+   */
+  value?: React.ReactNode;
+
+  /**
+   * Additional styling for badge (background) view component
+   */
+  badgeStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Style for the container
+   */
+  containerStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Style for the text in the badge
+   */
+  textStyle?: StyleProp<TextStyle>;
+
+  /**
+   * Custom component to replace the badge component
+   *
+   * @default View (if onPress then TouchableOpacity)
+   */
+  Component?: React.ComponentClass;
+
+  /**
+   * Determines color of the indicator
+   *
+   * @default primary
+   */
+  status?: "primary" | "success" | "warning" | "error";
+
+  /**
+   * Function called when pressed on the badge
+   */
+  onPress?(): void;
 }
 
 interface SwiperControlsProps {
-    /**
-     * Controls corners placeholders styles
-     */
-    cellsStyle?: SwiperControlsCellsStyle;
-
-    /**
-     * Controls corners placeholders additional content
-     */
-    cellsContent?: SwiperControlsCellsContent;
-
-    /**
-     * Dots position
-     *
-     * @default 'bottom' | 'right' if vertical
-     */
-    dotsPos?: SwiperControlsCorners | boolean;
-
-    /**
-     * Prev button position
-     *
-     * @default 'bottom-left' | 'top-right' if vertical
-     */
-    prevPos?: SwiperControlsCorners | boolean;
-
-    /**
-     * Next button position
-     *
-     * @default 'bottom-right'
-     */
-    nextPos?: SwiperControlsCorners | boolean;
-
-    /**
-     * Prev button title
-     *
-     * @default Prev
-     */
-    prevTitle?: string;
-
-    /**
-     * Next button title
-     *
-     * @default Next
-     */
-    nextTitle?: string;
-
-    /**
-     * Touches over dots will move swiper to relative slide
-     *
-     * @default false
-     */
-    dotsTouchable?: boolean;
-
-    /**
-     * Dots wrapper View style
-     */
-    dotsWrapperStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Customizing dot with Badge props
-     */
-    dotProps?: BadgeProps;
-
-    /**
-     * Additional style to active dot
-     */
-    dotActiveStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Custom dot component
-     */
-    DotComponent?: React.ComponentType<{ index: number, isActive: boolean, onPress: any }>;
-
-    /**
-     * Customize prev button title
-     */
-    prevTitleStyle?: StyleProp<TextStyle>;
-
-    /**
-     * Customize next button title
-     */
-    nextTitleStyle?: StyleProp<TextStyle>;
-
-    /**
-     * Custom prev button component
-     */
-    PrevComponent?: React.ComponentClass;
-
-    /**
-     * Custom next button component
-     */
-    NextComponent?: React.ComponentClass;
-
-    /**
-     * Custom prev element on first slide (if not loop)
-     */
-    firstPrevElement?: React.ReactElement<{}>;
-
-    /**
-     * Custom next element on last slide (if not loop)
-     */
-    lastNextElement?: React.ReactElement<{}>;
+  /**
+   * Controls corners placeholders styles
+   */
+  cellsStyle?: SwiperControlsCellsStyle;
+
+  /**
+   * Controls corners placeholders additional content
+   */
+  cellsContent?: SwiperControlsCellsContent;
+
+  /**
+   * Dots position
+   *
+   * @default 'bottom' | 'right' if vertical
+   */
+  dotsPos?: SwiperControlsCorners | boolean;
+
+  /**
+   * Prev button position
+   *
+   * @default 'bottom-left' | 'top-right' if vertical
+   */
+  prevPos?: SwiperControlsCorners | boolean;
+
+  /**
+   * Next button position
+   *
+   * @default 'bottom-right'
+   */
+  nextPos?: SwiperControlsCorners | boolean;
+
+  /**
+   * Prev button title
+   *
+   * @default Prev
+   */
+  prevTitle?: string;
+
+  /**
+   * Next button title
+   *
+   * @default Next
+   */
+  nextTitle?: string;
+
+  /**
+   * Touches over dots will move swiper to relative slide
+   *
+   * @default false
+   */
+  dotsTouchable?: boolean;
+
+  /**
+   * Dots wrapper View style
+   */
+  dotsWrapperStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Customizing dot with Badge props
+   */
+  dotProps?: BadgeProps;
+
+  /**
+   * Additional style to active dot
+   */
+  dotActiveStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Custom dot component
+   */
+  DotComponent?: React.ComponentType<{
+    index: number;
+    isActive: boolean;
+    onPress: any;
+    activeIndex: number;
+    numberOfSteps: number;
+  }>;
+  /**
+   * Customize prev button title
+   */
+  prevTitleStyle?: StyleProp<TextStyle>;
+
+  /**
+   * Customize next button title
+   */
+  nextTitleStyle?: StyleProp<TextStyle>;
+
+  /**
+   * Custom prev button component
+   */
+  PrevComponent?: React.ComponentType<T>;
+
+  /**
+   * Custom next button component
+   */
+  NextComponent?: React.ComponentType<T>;
+
+  /**
+   * Custom prev element on first slide (if not loop)
+   */
+  firstPrevElement?: React.ReactElement<{}>;
+
+  /**
+   * Custom next element on last slide (if not loop)
+   */
+  lastNextElement?: React.ReactElement<{}>;
 }
 
 // TODO: extends Animated.SpringAnimationConfig but without toValue
 interface SwiperSpringAnimationConfig {
-    overshootClamping?: boolean;
-    restDisplacementThreshold?: number;
-    restSpeedThreshold?: number;
-    velocity?: number | { x: number; y: number };
-    bounciness?: number;
-    speed?: number;
-    tension?: number;
-    friction?: number;
-    stiffness?: number;
-    mass?: number;
-    damping?: number;
+  overshootClamping?: boolean;
+  restDisplacementThreshold?: number;
+  restSpeedThreshold?: number;
+  velocity?: number | { x: number; y: number };
+  bounciness?: number;
+  speed?: number;
+  tension?: number;
+  friction?: number;
+  stiffness?: number;
+  mass?: number;
+  damping?: number;
 }
 
 export interface SwiperProps {
-    /**
-     * Swiper vertical layout
-     *
-     * @default false
-     */
-    vertical?: boolean;
-
-    /**
-     * Initial slide index
-     *
-     * @default 0
-     */
-    from?: number;
-
-    /**
-     * Allow loop
-     *
-     * @default false
-     */
-    loop?: boolean;
-
-    /**
-     * Autoplay slider timeout in secs. Negative value will play reverse
-     *
-     * @default 0 (autoplay disabled)
-     */
-    timeout?: number;
-
-    /**
-     * Should the swiper's swiping gesture be enabled?
-     *
-     * @default true
-     */
-    gesturesEnabled?: () => boolean;
-
-    /**
-     * Tune spring animation on autoplay, touch release or slides changes via buttons
-     */
-    springConfig?: SwiperSpringAnimationConfig;
-
-    /**
-     * Initiate animation after swipe this distance.
-     * It fix gesture collisions inside ScrollView
-     *
-     * @default 5
-     */
-    minDistanceToCapture?: number;
-
-    /**
-     * Minimal part of swiper width (or height for vertical) must be swiped
-     * for changing index. Otherwise animation restore current slide.
-     * Default value 0.2 means that 20% must be swiped for change index
-     *
-     * @default 0.2
-     */
-    minDistanceForAction?: number;
-
-    /**
-     * Swiper inner container position 'fixed' instead 'relative'.
-     * Fix mobile safari vertical bounces
-     *
-     * @default false
-     */
-    positionFixed?: boolean;
-
-    /**
-     * Outer (root) container style
-     */
-    containerStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Inner container style
-     */
-    innerContainerStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Swipe area style
-     */
-    swipeAreaStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Each slide wrapper style
-     */
-    slideWrapperStyle?: StyleProp<ViewStyle>;
-
-    /**
-     * Dots and control buttons enabled
-     *
-     * @default true
-     */
-    controlsEnabled?: boolean;
-
-    /**
-     * Controls Properties
-     */
-    controlsProps?: SwiperControlsProps;
-
-    /**
-     * Custom controls component
-     */
-    Controls?: React.ComponentClass;
-
-    /**
-     * Any swiper animation start
-     *
-     * @param currentIndex
-     */
-    onAnimationStart?(currentIndex: number): void;
-
-    /**
-     * Any swiper animation end
-     *
-     * @param index
-     */
-    onAnimationEnd?(index: number): void;
-
-    /**
-     * Called when active index changed
-     *
-     * @param index
-     */
-    onIndexChanged?(index: number): void;
-    
-    /**
-     *  Children props for functional components
-    */
-    children?: React.ReactNode;
+  /**
+   * Swiper vertical layout
+   *
+   * @default false
+   */
+  vertical?: boolean;
+
+  /**
+   * Initial slide index
+   *
+   * @default 0
+   */
+  from?: number;
+
+  /**
+   * Allow loop
+   *
+   * @default false
+   */
+  loop?: boolean;
+
+  /**
+   * Autoplay slider timeout in secs. Negative value will play reverse
+   *
+   * @default 0 (autoplay disabled)
+   */
+  timeout?: number;
+
+  /**
+   * Should the swiper's swiping gesture be enabled?
+   *
+   * @default true
+   */
+  gesturesEnabled?: () => boolean;
+
+  /**
+   * Tune spring animation on autoplay, touch release or slides changes via buttons
+   */
+  springConfig?: SwiperSpringAnimationConfig;
+
+  /**
+   * Initiate animation after swipe this distance.
+   * It fix gesture collisions inside ScrollView
+   *
+   * @default 5
+   */
+  minDistanceToCapture?: number;
+
+  /**
+   * Minimal part of swiper width (or height for vertical) must be swiped
+   * for changing index. Otherwise animation restore current slide.
+   * Default value 0.2 means that 20% must be swiped for change index
+   *
+   * @default 0.2
+   */
+  minDistanceForAction?: number;
+
+  /**
+   * Swiper inner container position 'fixed' instead 'relative'.
+   * Fix mobile safari vertical bounces
+   *
+   * @default false
+   */
+  positionFixed?: boolean;
+
+  /**
+   * Outer (root) container style
+   */
+  containerStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Inner container style
+   */
+  innerContainerStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Swipe area style
+   */
+  swipeAreaStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Each slide wrapper style
+   */
+  slideWrapperStyle?: StyleProp<ViewStyle>;
+
+  /**
+   * Dots and control buttons enabled
+   *
+   * @default true
+   */
+  controlsEnabled?: boolean;
+
+  /**
+   * Controls Properties
+   */
+  controlsProps?: SwiperControlsProps;
+
+  /**
+   * Custom controls component
+   */
+  Controls?: React.ComponentClass;
+
+  /**
+   * Any swiper animation start
+   *
+   * @param currentIndex
+   */
+  onAnimationStart?(currentIndex: number): void;
+
+  /**
+   * Any swiper animation end
+   *
+   * @param index
+   */
+  onAnimationEnd?(index: number): void;
+
+  /**
+   * Called when active index changed
+   *
+   * @param index
+   */
+  onIndexChanged?(index: number): void;
+
+  /**
+   *  Children props for functional components
+   */
+  children?: React.ReactNode;
 }
 
 /**
  * Swiper component
  */
 export default class Swiper extends React.Component<SwiperProps, any> {
-    /**
-     * Go to next slide
-     */
-    goToNext(): void;
-
-    /**
-     * Go to previous slide
-     */
-    goToPrev(): void;
-
-    /**
-     * Go to slide by index
-     */
-    goTo(index: number): void;
-
-    /**
-     * Get current slide index
-     */
-    getActiveIndex(): number;
-
-    /**
-     * Manual start autoplay after manual stop
-     */
-    startAutoplay(): void;
-
-    /**
-     * Manual stop autoplay. Will be automatically restarted after any animation
-     */
-    stopAutoplay(): void;
+  /**
+   * Go to next slide
+   */
+  goToNext(): void;
+
+  /**
+   * Go to previous slide
+   */
+  goToPrev(): void;
+
+  /**
+   * Go to slide by index
+   */
+  goTo(index: number): void;
+
+  /**
+   * Get current slide index
+   */
+  getActiveIndex(): number;
+
+  /**
+   * Manual start autoplay after manual stop
+   */
+  startAutoplay(): void;
+
+  /**
+   * Manual stop autoplay. Will be automatically restarted after any animation
+   */
+  stopAutoplay(): void;
 }
diff --git a/src/Controls.js b/src/Controls.js
index cf022f8eb91e1c0654d2b140a5cba5e5060dc035..793b9b76b76e725ed7d05d10d9371b24f0092c94 100644
--- a/src/Controls.js
+++ b/src/Controls.js
@@ -1,32 +1,32 @@
-import React from 'react';
-import PropTypes from 'prop-types';
-import { StyleSheet, Text, View } from 'react-native';
+import React from "react";
+import PropTypes from "prop-types";
+import { StyleSheet, Text, View } from "react-native";
 
-import { nodeType } from './nodeType';
-import { renderNode } from './renderNode';
+import { nodeType } from "./nodeType";
+import { renderNode } from "./renderNode";
 
-import { Badge } from './Badge';
-import { Button } from './Button';
+import { Badge } from "./Badge";
+import { Button } from "./Button";
 
-import colors from './colors';
+import colors from "./colors";
 
 const cellPositions = [
-  'top-left',
-  'top',
-  'top-right',
-  'left',
-  'center',
-  'right',
-  'bottom-left',
-  'bottom',
-  'bottom-right',
+  "top-left",
+  "top",
+  "top-right",
+  "left",
+  "center",
+  "right",
+  "bottom-left",
+  "bottom",
+  "bottom-right",
 ];
 
 export default class DefaultControls extends React.Component {
-  dotsPos = (() => this._getPos(this.props.dotsPos, 'bottom', 'right'))();
+  dotsPos = (() => this._getPos(this.props.dotsPos, "bottom", "right"))();
   prevPos = (() =>
-    this._getPos(this.props.prevPos, 'bottom-left', 'top-right'))();
-  nextPos = (() => this._getPos(this.props.nextPos, 'bottom-right'))();
+    this._getPos(this.props.prevPos, "bottom-left", "top-right"))();
+  nextPos = (() => this._getPos(this.props.nextPos, "bottom-right"))();
 
   constructor(props) {
     super(props);
@@ -77,6 +77,7 @@ export default class DefaultControls extends React.Component {
       dotsWrapperStyle,
       DotComponent = this._renderDot,
       goTo,
+      numberOfSteps,
     } = this.props;
     return (
       <View
@@ -85,13 +86,14 @@ export default class DefaultControls extends React.Component {
           dotsWrapperStyle,
         ])}
       >
-        {Array.from({ length: count }, (v, i) => i).map(index => (
+        {Array.from({ length: count }, (v, i) => i).map((index) => (
           <DotComponent
             key={index}
             index={index}
             activeIndex={activeIndex}
             isActive={activeIndex === index}
             onPress={!dotsTouchable ? undefined : () => goTo(index)}
+            numberOfSteps={numberOfSteps}
           />
         ))}
       </View>
@@ -105,7 +107,10 @@ export default class DefaultControls extends React.Component {
         type="clear"
         onPress={onPress}
         title={title}
-        titleStyle={StyleSheet.flatten([styles.buttonTitleStyle({ colors }, type), titleStyle])}
+        titleStyle={StyleSheet.flatten([
+          styles.buttonTitleStyle({ colors }, type),
+          titleStyle,
+        ])}
         {...props}
       />
     );
@@ -170,11 +175,11 @@ export default class DefaultControls extends React.Component {
   _renderRow({ rowAlign }) {
     const Cell = this._renderCell;
     const row = [
-      `${!rowAlign ? '' : rowAlign + '-'}left`,
-      rowAlign || 'center',
-      `${!rowAlign ? '' : rowAlign + '-'}right`,
+      `${!rowAlign ? "" : rowAlign + "-"}left`,
+      rowAlign || "center",
+      `${!rowAlign ? "" : rowAlign + "-"}right`,
     ];
-    const alignItems = ['flex-start', 'center', 'flex-end'];
+    const alignItems = ["flex-start", "center", "flex-end"];
     return (
       <View style={styles.row}>
         {row.map((name, index) => (
@@ -246,35 +251,36 @@ DefaultControls.propTypes = {
   goToPrev: PropTypes.func,
   goToNext: PropTypes.func,
   goTo: PropTypes.func,
+  numberOfSteps: PropTypes.number,
 };
 
 DefaultControls.defaultProps = {
-  prevTitle: 'Prev',
-  nextTitle: 'Next',
+  prevTitle: "Prev",
+  nextTitle: "Next",
 };
 
 const styles = {
   row: {
-    flexDirection: 'row',
+    flexDirection: "row",
     height: 0,
-    alignItems: 'center',
+    alignItems: "center",
     margin: 20,
   },
-  spaceHolder: alignItems => ({
+  spaceHolder: (alignItems) => ({
     height: 0,
     flex: 1,
     alignItems,
-    justifyContent: 'center',
+    justifyContent: "center",
   }),
   cell: {
-    alignItems: 'center',
-    justifyContent: 'center',
-    position: 'absolute',
+    alignItems: "center",
+    justifyContent: "center",
+    position: "absolute",
   },
-  dotsWrapper: vertical => ({
-    flexDirection: vertical ? 'column' : 'row',
-    alignItems: 'center',
-    justifyContent: 'center',
+  dotsWrapper: (vertical) => ({
+    flexDirection: vertical ? "column" : "row",
+    alignItems: "center",
+    justifyContent: "center",
     minWidth: 1,
     minHeight: 1,
   }),
@@ -283,10 +289,10 @@ const styles = {
   },
   dotsItem: (theme, isActive) => ({
     backgroundColor: isActive ? theme.colors.primary : theme.colors.grey3,
-    borderColor: 'transparent',
+    borderColor: "transparent",
   }),
   buttonTitleStyle: (theme, type) => ({
-    color: type === 'prev' ? theme.colors.grey3 : theme.colors.primary,
+    color: type === "prev" ? theme.colors.grey3 : theme.colors.primary,
   }),
   hidden: {
     opacity: 0,
