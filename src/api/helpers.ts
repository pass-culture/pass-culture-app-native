/* eslint-disable @typescript-eslint/ban-ts-comment */
import { t } from '@lingui/macro'
import jwtDecode from 'jwt-decode'

import { api } from 'api/api'
import { Headers, FailedToRefreshAccessTokenError } from 'libs/fetch'
import { _ } from 'libs/i18n'
import { clearRefreshToken, getRefreshToken } from 'libs/keychain'
import { clearAccessToken, getAccessToken, saveAccessToken } from 'libs/storage'

export async function getAuthenticationHeaders(options?: RequestInit): Promise<Headers> {
  const accessToken = await getAccessToken()
  const shouldAuthenticate = accessToken && (!options || options.credentials !== 'omit')
  if (shouldAuthenticate) {
    return { Authorization: `Bearer ${accessToken}` }
  }
  return {}
}

interface JWTToken {
  exp: number
  fresh: false
  iat: number
  identity: string
  jti: string
  nbf: number
  type: string
}

/**
 * For each http calls to the api, retrieves the access token and fetchs.
 * Ignores native/v1/refresh_access_token.
 *
 * First decodes the local access token:
 * on success: continue to the call
 * on error (401): try to refresh the access token
 * on error (other): propagates error
 */
export const getValidTokenAndFetch = async (
  url: string,
  options: RequestInit
): Promise<Response> => {
  // dont ask a new token for this specific api call
  if (url.includes('native/v1/refresh_access_token')) {
    return await fetch(url, options)
  }

  // @ts-ignore
  const authorizationHeader = options.headers?.['Authorization'] || ''
  const token = authorizationHeader?.replace('Bearer ', '')

  try {
    const tokenContent = jwtDecode(token) as JWTToken

    if (tokenContent.exp * 1000 <= new Date().getTime()) {
      throw new Error('Token expired')
    }
  } catch (error) {
    const newAccessToken = await refreshAccessToken()

    options = {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${newAccessToken}`,
      },
    }
  }

  return await fetch(url, options)
}

/**
 * Calls Api to refresh the access token using the in-keychain stored refresh token
 * - on success: Stores the new access token
 * - on error (422): propagates error
 * - on error (other): throws an exception
 */
export const refreshAccessToken = async (): Promise<string | null> => {
  const refreshToken = await getRefreshToken()

  // if not connected, we also redirect to the login page
  if (refreshToken == null) {
    throw new FailedToRefreshAccessTokenError()
  }

  const response = await api.nativeV1RefreshAccessTokenPost({
    headers: {
      Authorization: `Bearer ${refreshToken}`,
    },
  })

  if (!response) {
    await clearRefreshToken()
    await clearAccessToken()
    // assumes that error will be catched by an error boundary in order
    // to redirect the user to the login page
    throw new FailedToRefreshAccessTokenError()
  }

  await saveAccessToken(response.accessToken)

  return await getAccessToken()
}

// In this case, the following `any` is not that much of a problem in the context of usage
// with the autogenerated files of swagger-codegen.
// !!! Not encouraging to use `any` anywhere else !!!
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function handleGeneratedApiResponse(response: Response): Promise<any | void> {
  if (response.status === 204) {
    return {}
  }

  if (!response.ok) {
    throw new Error(_(t`Échec de la requête ${response.url}, code: ${response.status}`))
  }

  return await response.json()
}
